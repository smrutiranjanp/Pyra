# Pyra Programming Language: A Comprehensive Guide

## Table of Contents

1. Introduction to Pyra
2. Getting Started with Pyra
3. Core Syntax and Features
4. Advanced Features
5. Object-Oriented Programming in Pyra
6. Error Handling
7. Concurrency in Pyra
8. Data Transformation and Pipelines
9. Built-In Libraries
10. Tooling and Ecosystem
11. Sample Programs
12. Building Pyra: The Interpreter (Conceptual Overview)

---

## Chapter 1: Introduction to Pyra

**Pyra** is a modern programming language designed to blend the simplicity of Python with advanced features tailored for modern software development, such as concurrency, immutability, and streamlined data transformation. Its syntax is concise, readable, and strongly typed with optional type inference, making it ideal for beginners and professionals alike.

### Key Design Principles

- **Simplicity**: Easy to learn and use, with a clean syntax.
- **Performance**: Features like immutability and concurrency make Pyra efficient.
- **Scalability**: Built for tasks ranging from scripting to large-scale application development.

---

## Chapter 2: Getting Started with Pyra

### Installation

Download the Pyra interpreter from [Pyra's official website](https://pyra-lang.org). Install it via the command line:

```bash
$ curl -O https://pyra-lang.org/install.pyra
$ python3 install.pyra
```

### Running a Pyra Script

Save your Pyra code in a file with the `.pyra` extension. Run it using the Pyra interpreter:

```bash
$ pyra script.pyra
```

### REPL Mode

For interactive programming, start the Pyra REPL:

```bash
$ pyra
Pyra 1.0.0
>>>
```

---

## Chapter 3: Core Syntax and Features

### Variables

```pyra
# Immutable by default
x = 42
name = "Pyra"

# Mutable declaration
mutable count = 0
count = 1  # Allowed
```

### Data Types

Pyra supports basic and complex data types:

```pyra
# Primitives
num: Int = 10
pi: Float = 3.14
is_ready: Bool = true

# Complex types
list_numbers: List[Int] = [1, 2, 3]
dict_data: Dict[String, Int] = {"one": 1, "two": 2}
```

### Functions

```pyra
# Function with inferred types
def greet(name):
    return "Hello, " + name

# Function with explicit types
def add(a: Int, b: Int) -> Int:
    return a + b
```

---

## Chapter 4: Advanced Features

### Immutability

Variables are immutable by default, promoting safe concurrency:

```pyra
x = 10
x = 20  # Error: Cannot reassign immutable variable
```

### Pattern Matching

```pyra
match value:
    case 1:
        print("One")
    case 2:
        print("Two")
    case _:
        print("Other")
```

---

## Chapter 5: Object-Oriented Programming in Pyra

### Classes

```pyra
class Animal:
    def __init__(self, name: String):
        self.name = name

    def speak(self):
        return "I am " + self.name

class Dog(Animal):
    def speak(self):
        return "Woof! I am " + self.name
```

---

## Chapter 6: Error Handling

```pyra
try:
    risky_function()
except ValueError as e:
    print("Caught ValueError:", e)
finally:
    print("Cleanup done")
```

---

## Chapter 7: Concurrency in Pyra

### Coroutines

```pyra
async def fetch_data(url):
    print("Fetching", url)
    return "Data from " + url

# Running multiple coroutines
def main():
    results = await [fetch_data("url1"), fetch_data("url2")]
    print(results)
```

---

## Chapter 8: Data Transformation and Pipelines

```pyra
# Pipeline for data transformations
data = [1, 2, 3, 4, 5]

result = data | map(x -> x * 2) | filter(x -> x > 5) | to_list()
print(result)  # [6, 8, 10]
```

---

## Chapter 9: Built-In Libraries

Pyra includes libraries for:

- **HTTP requests**
- **Data processing**
- **Math operations**
- **File I/O**

---

## Chapter 10: Tooling and Ecosystem

### Pyra CLI

```bash
# Running a script
$ pyra script.pyra

# Installing a package
$ pyrainstall package_name
```

---

## Chapter 11: Sample Programs

### Fibonacci Sequence

```pyra
def fibonacci(n: Int) -> List[Int]:
    a, b = 0, 1
    result = []
    for _ in range(n):
        result.append(a)
        a, b = b, a + b
    return result

print(fibonacci(10))
```

---

## Chapter 12: Building Pyra: The Interpreter

The Pyra interpreter is the engine that executes Pyra programs. It consists of three main components:

### 1. Lexer (Tokenizer)

The lexer reads the source code and breaks it into a sequence of tokens, which are the smallest meaningful units in the code (e.g., keywords, identifiers, operators).

```python
# Example of tokenizing Pyra code
source_code = "x = 42"
tokens = [
    {"type": "IDENTIFIER", "value": "x"},
    {"type": "OPERATOR", "value": "="},
    {"type": "NUMBER", "value": 42}
]
```

### 2. Parser

The parser takes the tokens generated by the lexer and builds an Abstract Syntax Tree (AST), which represents the structure of the code.

```python
# Example of parsing tokens into an AST
ast = {
    "type": "Assignment",
    "left": {"type": "Identifier", "name": "x"},
    "right": {"type": "Number", "value": 42}
}
```

### 3. Evaluator

The evaluator traverses the AST and executes the code. For example, it assigns the value `42` to the variable `x` in the program's memory.

```python
# Example of evaluating the AST
memory = {}
def evaluate(node):
    if node["type"] == "Assignment":
        memory[node["left"]["name"]] = node["right"]["value"]

evaluate(ast)
print(memory)  # Output: {"x": 42}
```

### 4. Runtime

The Pyra runtime provides the environment for executing Pyra programs. It includes built-in libraries, garbage collection, and support for concurrency.

---

### bu

For a detailed implementation guide, visit the [Pyra GitHub Repository](https://github.com/pyra-lang).

---

